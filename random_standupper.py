import datetime
import json
import random
from pathlib import Path
from typing import Dict, List, Set

import sys


# 1. Пул имён
NAMES = [
    "Аня",
    "Вася",
    "Петя",
    "Маша",
    "Никодим",
    "Матвей",
    "Арсений",
    "Ксеня",
    "Илья",
]

YEAR = 2026
ASSIGNMENTS_FILE = "assignments_2026.json"

# Список всех рабочих дней 2026 года (is_working == 1 в исходном CSV)
WORKING_DAYS_2026: List[str] = [
    # Январь
    "2026-01-12", "2026-01-13", "2026-01-14", "2026-01-15", "2026-01-16",
    "2026-01-19", "2026-01-20", "2026-01-21", "2026-01-22", "2026-01-23",
    "2026-01-26", "2026-01-27", "2026-01-28", "2026-01-29", "2026-01-30",
    # Февраль
    "2026-02-02", "2026-02-03", "2026-02-04", "2026-02-05", "2026-02-06",
    "2026-02-09", "2026-02-10", "2026-02-11", "2026-02-12", "2026-02-13",
    "2026-02-16", "2026-02-17", "2026-02-18", "2026-02-19", "2026-02-20",
    "2026-02-24", "2026-02-25", "2026-02-26", "2026-02-27",
    # Март
    "2026-03-02", "2026-03-03", "2026-03-04", "2026-03-05", "2026-03-06",
    "2026-03-10", "2026-03-11", "2026-03-12", "2026-03-13",
    "2026-03-16", "2026-03-17", "2026-03-18", "2026-03-19", "2026-03-20",
    "2026-03-23", "2026-03-24", "2026-03-25", "2026-03-26", "2026-03-27",
    "2026-03-30", "2026-03-31",
    # Апрель
    "2026-04-01", "2026-04-02", "2026-04-03",
    "2026-04-06", "2026-04-07", "2026-04-08", "2026-04-09", "2026-04-10",
    "2026-04-13", "2026-04-14", "2026-04-15", "2026-04-16", "2026-04-17",
    "2026-04-20", "2026-04-21", "2026-04-22", "2026-04-23", "2026-04-24",
    "2026-04-27", "2026-04-28", "2026-04-29", "2026-04-30",
    # Май
    "2026-05-04",
    "2026-05-05", "2026-05-06", "2026-05-07", "2026-05-08",
    "2026-05-12", "2026-05-13", "2026-05-14", "2026-05-15",
    "2026-05-18", "2026-05-19", "2026-05-20", "2026-05-21", "2026-05-22",
    "2026-05-25", "2026-05-26", "2026-05-27", "2026-05-28", "2026-05-29",
    # Июнь
    "2026-06-01", "2026-06-02", "2026-06-03", "2026-06-04", "2026-06-05",
    "2026-06-08", "2026-06-09", "2026-06-10", "2026-06-11",
    "2026-06-15", "2026-06-16", "2026-06-17", "2026-06-18", "2026-06-19",
    "2026-06-22", "2026-06-23", "2026-06-24", "2026-06-25", "2026-06-26",
    "2026-06-29", "2026-06-30",
    # Июль
    "2026-07-01", "2026-07-02", "2026-07-03",
    "2026-07-06", "2026-07-07", "2026-07-08", "2026-07-09", "2026-07-10",
    "2026-07-13", "2026-07-14", "2026-07-15", "2026-07-16", "2026-07-17",
    "2026-07-20", "2026-07-21", "2026-07-22", "2026-07-23", "2026-07-24",
    "2026-07-27", "2026-07-28", "2026-07-29", "2026-07-30", "2026-07-31",
    # Август
    "2026-08-03", "2026-08-04", "2026-08-05", "2026-08-06", "2026-08-07",
    "2026-08-10", "2026-08-11", "2026-08-12", "2026-08-13", "2026-08-14",
    "2026-08-17", "2026-08-18", "2026-08-19", "2026-08-20", "2026-08-21",
    "2026-08-24", "2026-08-25", "2026-08-26", "2026-08-27", "2026-08-28",
    "2026-08-31",
    # Сентябрь
    "2026-09-01", "2026-09-02", "2026-09-03", "2026-09-04",
    "2026-09-07", "2026-09-08", "2026-09-09", "2026-09-10", "2026-09-11",
    "2026-09-14", "2026-09-15", "2026-09-16", "2026-09-17", "2026-09-18",
    "2026-09-21", "2026-09-22", "2026-09-23", "2026-09-24", "2026-09-25",
    "2026-09-28", "2026-09-29", "2026-09-30",
    # Октябрь
    "2026-10-01", "2026-10-02",
    "2026-10-05", "2026-10-06", "2026-10-07", "2026-10-08", "2026-10-09",
    "2026-10-12", "2026-10-13", "2026-10-14", "2026-10-15", "2026-10-16",
    "2026-10-19", "2026-10-20", "2026-10-21", "2026-10-22", "2026-10-23",
    "2026-10-26", "2026-10-27", "2026-10-28", "2026-10-29", "2026-10-30",
    # Ноябрь
    "2026-11-02", "2026-11-03",
    "2026-11-05", "2026-11-06",
    "2026-11-09", "2026-11-10", "2026-11-11", "2026-11-12", "2026-11-13",
    "2026-11-16", "2026-11-17", "2026-11-18", "2026-11-19", "2026-11-20",
    "2026-11-23", "2026-11-24", "2026-11-25", "2026-11-26", "2026-11-27",
    "2026-11-30",
    # Декабрь
    "2026-12-01", "2026-12-02", "2026-12-03", "2026-12-04",
    "2026-12-07", "2026-12-08", "2026-12-09", "2026-12-10", "2026-12-11",
    "2026-12-14", "2026-12-15", "2026-12-16", "2026-12-17", "2026-12-18",
    "2026-12-21", "2026-12-22", "2026-12-23", "2026-12-24", "2026-12-25",
    "2026-12-28", "2026-12-29", "2026-12-30",
]


def load_working_days_from_df() -> List[datetime.date]:
    """
    Возвращает отсортированный список рабочих дней из встроенного списка строк.
    """
    working_days: List[datetime.date] = [
        datetime.date.fromisoformat(d) for d in WORKING_DAYS_2026
    ]
    return sorted(working_days)


def assign_names_to_days(
    names: List[str],
    working_days: List[datetime.date],
    skip_names: Set[str] | None = None,
) -> Dict[datetime.date, str]:
    """
    Распределяет имена по всем рабочим дням года.

    - skip_names: имена, которые не участвуют в рандомизации.
    - внутри одного цикла по всем доступным именам выбор без возвращения,
      затем цикл повторяется с новой случайной перестановкой имён.
    """
    if skip_names is None:
        skip_names = set()

    available = [n for n in names if n not in skip_names]
    if not available:
        raise ValueError("Нет доступных имён для распределения (все в списке пропуска).")

    assignments: Dict[datetime.date, str] = {}
    pool: List[str] = []

    for day in sorted(working_days):
        if not pool:
            pool = available[:]
            random.shuffle(pool)
        assignments[day] = pool.pop()

    return assignments


def load_assignments(path: str = ASSIGNMENTS_FILE) -> dict | None:
    """Загружает сохранённое распределение докладчиков, если есть."""
    file_path = Path(path)
    if not file_path.exists():
        return None

    try:
        with file_path.open(encoding="utf-8") as f:
            return json.load(f)
    except json.JSONDecodeError:
        return None


def save_assignments(
    assignments: Dict[datetime.date, str],
    skip_names: Set[str],
    path: str = ASSIGNMENTS_FILE,
) -> None:
    """Сохраняет распределение докладчиков и список пропускающих в JSON."""
    data = {
        "year": YEAR,
        "skip_names": sorted(skip_names),
        "assignments": {
            day.isoformat(): name for day, name in assignments.items()
        },
    }
    Path(path).write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")


def main(skip_names: List[str] | None = None) -> None:
    """
    Основная функция.

    skip_names — список имён, которые нужно пропустить при рандомизации.
    Если список не пустой, ВСЕ рабочие дни года пересчитываются заново.
    """
    if skip_names is None:
        skip_names = []

    today = datetime.date.today()
    working_days = load_working_days_from_df()

    # Если сегодня нерабочий день
    if today not in working_days:
        print("сегодня отдыхаем-с!")
        return

    skip_set = set(skip_names)

    # Пытаемся загрузить сохранённое распределение
    stored = load_assignments()
    assignments: Dict[datetime.date, str] | None = None

    if stored and stored.get("year") == YEAR:
        stored_skip = set(stored.get("skip_names", []))
        if stored_skip == skip_set:
            stored_map = stored.get("assignments", {})
            # Проверим, что в сохранённом есть все текущие рабочие дни
            if all(d.isoformat() in stored_map for d in working_days):
                assignments = {
                    datetime.date.fromisoformat(d): name
                    for d, name in stored_map.items()
                }

    # Если нет валидного сохранённого — пересчитываем целый год
    if assignments is None:
        assignments = assign_names_to_days(NAMES, working_days, skip_set)
        save_assignments(assignments, skip_set)

    # На выходе — только докладчик на сегодня
    speaker = assignments.get(today)
    if speaker:
        print(speaker)
    else:
        print("сегодня отдыхаем-с!")


if __name__ == "__main__":
    # Имена для пропуска можно передать аргументами командной строки:
    #   python random_standupper.py Вася Петя
    # По умолчанию список пустой.
    args = sys.argv[1:]
    main(args)

